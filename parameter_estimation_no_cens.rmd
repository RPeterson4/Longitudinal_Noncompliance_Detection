### Code to estimate parameters for simulated data with no left-censoring.
### Sample size set to n = 10000 with K = 5 time points.
### Code takes 2 minutes to run.
### Parameters defaulted to the simulation scenario where $\alpha_1=-1.8$.

```{r, cache = TRUE}
## Packages for multivariate normal distribution and compliance patterns
library(mvtnorm)
library(gtools)

## Set sample size (n), time points (t), and true parameter values
n = 10000; t = 5;
alpha0_t = 4.0; alpha1_t = -1.8; tau_t = 0.7; sigma_t = 0.3
beta0_t = 0; gamma_t = 1

## Variables required for calculating compliance patterns
ps = permutations(2,t,v=0:1,repeats.allowed=TRUE)
cam = ps[rep(1:2^t,n),]
lu_mat = cbind(apply(ps,2,function(x){ifelse(x==1,-Inf,0)}),
	apply(ps,2,function(x){ifelse(x==1,0,Inf)}))

## Helper function for calculating multivariate normal CDF for each row of a matrix for probit model
pfun = function(vec,beta0,s_mat,time){
	set.seed(1)
	return(pmvnorm(vec[1:time],vec[(time+1):(2*time)],
	-beta0,sigma=s_mat)[1])
}

## Compliance log likelihood assuming a probit link
pnlog_lik = function(x,w){
	return(-sum(w*log(apply(lu_mat,1,pfun,beta0=x[1],
	s_mat=matrix(c(1+exp(x[2]),rep(c(rep(exp(x[2]),t),1+exp(x[2])),t-1)),
	nrow=t),time=t))))
}

## Biomarker log likelihood assuming an identity link with no censoring
bnlog_lik = function(x,bset,w){
	return(-sum(w*dmvnorm(bset-x[1]-x[2]*cam, 
	sigma=matrix(c(exp(x[3])+exp(x[4]),rep(c(rep(exp(x[3]),t),exp(x[3])+exp(x[4])),t-1)),
	nrow=t),log=TRUE)))
}

## Data generation
set.seed(1)
rs = rnorm(n,0,sqrt(gamma_t))
rs2 = rnorm(n,0,sqrt(tau_t))		
b_mat = matrix(NA, n, t)
c_mat = matrix(NA, n, t)
for(j in 1:t){
	c_mat[,j] = rbinom(n,1,pnorm(beta0_t+rs))
	b_mat[,j] = rnorm(n,alpha0_t+alpha1_t*c_mat[,j]+rs2,sqrt(sigma_t))
}

## Replicate biomarker matrix 2^t times for each compliance pattern
bam = b_mat[rep(1:nrow(b_mat),rep(2^t,n)),]

## Set starting values of EM algorithm at truth
oe = c(alpha0_t,alpha1_t,tau_t,sigma_t,beta0_t,gamma_t)

rel_diff = 10; iter = 0; oinc = 1e6; s = -1;
res = rbind(c(oe,iter,s))

q = Sys.time()

## The EM algorithm
while(rel_diff > 1e-05){
	## E step
	probs = apply(lu_mat,1,pfun,beta0=oe[5],
		s_mat=matrix(c(1+oe[6],rep(c(rep(oe[6],t),1+oe[6]),t-1)),
		nrow=t),time=t)
	
	fs = dmvnorm(bam-oe[1]-oe[2]*cam,
		sigma=matrix(c(oe[3]+oe[4],rep(c(rep(oe[3],t),oe[3]+oe[4]),t-1)),
		nrow=t))

	m = matrix(probs*fs,nrow=2^t)
	wvec = as.vector(t(t(m)/colSums(m)))

	## M step
	init = c(oe[1],oe[2],log(oe[3]),log(oe[4]))
	e1 = optim(par=init,fn=bnlog_lik,bset=bam,w=wvec,method="BFGS")$par
			
	init2 = c(oe[5],log(oe[6]))
	e2 = optim(par=init2,fn=pnlog_lik,w=wvec,method="BFGS")$par	

	## Calculate relative difference in parameter estimates as a terminating condition
	rel_diff = sum(abs((c(e1[1:2],exp(e1[3:4]),e2[1],exp(e2[2]))-oe)/oe))

	iter = iter + 1
	oe = c(e1[1:2],exp(e1[3:4]),e2[1],exp(e2[2]))

	## Calculate negative incomplete log likelihood, should decrease with each EM step
	probsn = apply(lu_mat,1,pfun,beta0=e2[1],
		s_mat=matrix(c(1+exp(e2[2]),rep(c(rep(exp(e2[2]),t),1+exp(e2[2])),t-1)),
		nrow=t),time=t)

	fsn = dmvnorm(bam-e1[1]-e1[2]*cam, 
		sigma=matrix(c(exp(e1[3])+exp(e1[4]),rep(c(rep(exp(e1[3]),t),exp(e1[3])+exp(e1[4])),t-1)),
		nrow=t)) 

	ninc = -sum(log(colSums(matrix(probsn*fsn,nrow=2^t))))

	## Sign of difference in incomplete negative log likelihoods between iterations, should be negative
	s = sign(ninc-oinc)

	oinc = ninc
	res = rbind(res,c(oe,iter,s))
}

print(Sys.time()-q)

res2 = cbind(res[,5:6],res[,1:4],res[,7:8])
colnames(res2) = c("beta0","gamma_sq","alpha0","alpha1","tau_sq","sigma_sq","iter","decrease in incomplete negative log likelihood?")
print(res2)

## Comparison of parameter estimates to truth
comp_mat = rbind(c(beta0_t,gamma_t,alpha0_t,alpha1_t,tau_t,sigma_t),c(res2[nrow(res2),1:2],res2[nrow(res2),3:6]))
rownames(comp_mat) = c("Truth", "Estimate")
print(comp_mat)
```